%{
open FSharp.Text.Parsing
open AST

// Auxiliary function to compute the position an AST node
let pos (parseState: IParseState, inputIdx: int): AST.Position =
  let mainPos = parseState.InputStartPosition inputIdx
  let (rstart, rend) = parseState.ResultRange
  { FileName = mainPos.FileName
    Line = mainPos.pos_lnum + 1 // Line numbering from 1
    Col = mainPos.pos_cnum - mainPos.pos_bol + 1 // Line numbering from 1
    LineStart = rstart.pos_lnum + 1 // Row numbering from 1
    ColStart = rstart.pos_cnum - rstart.pos_bol + 1 // Column numbering from 1
    LineEnd = rend.pos_lnum + 1
    ColEnd = rend.pos_cnum - rend.pos_bol } // No +1: cover last-used character

// Auxiliary function to build an untyped AST node for a Hygge expression.
// 'inputIdx' is the index of the symbol to use for computing the position of
// this expression (it will be used e.g. when reporting error messages).
let mkNode (parseState: IParseState, inputIdx: int, node: 'C): AST.Node<'C> =
    printfn "mkNode %A" inputIdx;
    { Pos = pos(parseState, inputIdx) ; NodeCategory = node }

%}

%start program
%type <AST.Node<AST.SchemeDecl>> program
// Define constants
%token <bool> LIT_BOOL
%token <int> LIT_INT
%token <single> LIT_FLOAT
%token <unit> LIT_UNIT
%token <string> STRING_LITERAL

%token <string> IDENT
%token BOOL INT

%token SCHEME CLASS TYPE VALUE LET IN IF THEN ELSE AXIOM TEST_CASE END EOF ABS
%token AND OR NOT
%token SEMICOLON COLON COMMA LPAREN RPAREN LBRACK RBRACK LCURLY RCURLY
%token RARROW PARTIAL_RARROW IMPLIES LSUBSET RSUBSET LSUBSET_EQUALS RSUBSET_EQUALS
%token SET INFSET LIST INFLIST DOT
%token IS UNION PRODUCT INTERSECTION BELONGS NOT_BELONGS EXISTS CHOICE FORALL

%token EQUALS NOT_EQUALS GT LT GTE LTE GEQ LEQ
%token PLUS MINUS
%token MULTIPLY DIVIDE
%token EXPONENT

%right FORALL EXISTS
%right IMPLIES
%right OR
%right AND
%left EQUALS NOT_EQUALS GT LT GEQ LEQ
%left PLUS MINUS
%left MULTIPLY DIVIDE

%%

program:
    | SCHEME schemeDef EOF 
        { 

            printfn "SchemeDeclNode %A" $2;
            mkNode(parseState, 1, {
                schemeDef = $2;
            })

        }

schemeDef:
    | ident EQUALS classExpr 
        {
            printfn "SchemeDefNode %A %A" $1 $3;
            mkNode(parseState, 1, {
                name = $1;
                classExpr = $3;
            })
        
        }

classExpr:
    | CLASS optDeclStringExpr END 
        { 
            printfn "ClassExprNode %A" $2;
            mkNode(parseState, 1,{
                optDecl = $2;
            })
        
        }

optDeclStringExpr:
    | declExprList { $1 }

declExprList:
    | declExpr declExprList { $1 :: $2 }
    | declExpr { [$1] }

declExpr:
    | typeDecl { Decl.TypeDecl($1) }
    | valueDecl { Decl.ValueDecl($1) }
    | axiomDecl { Decl.AxiomDecl($1) }

typeDecl:
    | TYPE typeDefList
        { 
            (mkNode(parseState, 1, {
                typeDefList = $2
            }))
        
        }

typeDefList:
    | typeDef COMMA typeDefList { $1 :: $3 }
    | typeDef { [$1] }

typeDef:
    | sortDefExpr { TypeDef.SortDef($1) }
    | variantDefExpr { TypeDef.VariantDef($1) }
    | abbrevDefExpr { TypeDef.AbbrevDef($1) }

sortDefExpr:
    | ident
        {
            mkNode(parseState, 1, {
                name = $1;
            })
        
        }

variantDefExpr:
    | ident EQUALS EQUALS identChoice
        {
            mkNode(parseState, 1,{
                name = $1;
                choice = $4;
            })
        
        
        }

identChoice:
    | IDENT CHOICE identChoice { $1 :: $3 }
    | IDENT { [$1] }

abbrevDefExpr:
    | ident EQUALS typeExpr
        {
            mkNode(parseState, 1,{
                name = $1;
                typeExpr = $3;
            })
        
        }

valueDecl:
    | VALUE valueDefList
        {
            (mkNode(parseState, 1,{
                valueDefList = $2
            }))
        
        }

valueDefList:
    | valueDef COMMA valueDefList { $1 :: $3 }
    | valueDef { [$1] }

valueDef:
    | explicitValueDef { ValueDef.ExplicitValueDef($1) }
    | explicitFunctionDef { ValueDef.ExplicitFunctionDef($1) }
    | valueSignatureExpr { ValueDef.ValueSignature($1) }

valueSignatureExpr:
    | ident COLON typeExpr
        {
            mkNode(parseState, 1,{
                name = $1;
                typeExpr = $3;
            })
        
        }

explicitValueDef:
    | ident COLON typeExpr EQUALS valueExpr
        {
            printfn "ExplicitValueDefNode %A %A %A" $1 $3 $5;
            mkNode(parseState, 1,{
                name = $1;
                typeExpr = $3;
                valueExpr = $5;
            })
        
        }

explicitFunctionDef:
    | ident COLON typeExprProduct functionDeclOp typeExpr explicitFunctionBodyExpr
        {
            mkNode(parseState, 1,{
                name = $1;
                args = $3;
                functionDeclOperator = $4;
                returnTypeExpr = $5;
                bodyExpr = $6;
            })
        
        }

functionDeclOp:
    | PARTIAL_RARROW { FunctionDeclOperator.PartialArrow }
    | RARROW { FunctionDeclOperator.Arrow }

explicitFunctionBodyExpr:
    | ident LPAREN identList RPAREN functionDefOp valueExpr
        {
            mkNode(parseState, 1,{
                name = $1;
                args = $3;
                functionDefOperator = $5;
                valueExpr = $6;
            })
        
        }

functionDefOp:
    | IS { FunctionDefOperator.Is }

identList:
    | ident COMMA identList { $1 :: $3 }
    | ident { [$1] }
    | { [] }

axiomDecl:
    | AXIOM axiomDefList
        {
            (mkNode(parseState, 1,{
                axiomDefList = $2
            }))
        
        }
    

axiomDefList:
    | axiomDef COMMA axiomDefList { $1 :: $3 }
    | axiomDef { [$1] }

axiomDef:
    | optionAxiomName valueExpr
        {
            mkNode(parseState, 1,{
                name = $1;
                logicalValueExpr = $2;
            })
        
        }
    | valueExpr
        {
            mkNode(parseState, 1,{
                name = "";
                logicalValueExpr = $1;
            })
        
        }

optionAxiomName:
    | LBRACK ident RBRACK { $2 }

typeExpr:
    | typeLiteralExpr { mkNode(parseState, 1, TypeExpr.TypeLiteral($1)) }
    | typeNameExpr { mkNode(parseState, 1, TypeExpr.TypeName($1)) }
    | subtypeExpr { mkNode(parseState, 1, TypeExpr.SubtypeExpr($1)) }
    | bracketedTypeExpr { mkNode(parseState, 1, TypeExpr.BracketedTypeExpr($1)) }

typeLiteralExpr:
    | BOOL { printfn "TypeLiteralBoolNode"; mkNode(parseState, 1, TypeLiteral.Bool) }
    | INT { printfn "TypeLiteralIntNode"; mkNode(parseState, 1, TypeLiteral.Int) }

typeNameExpr:
    | ident 
        { 
            printfn "TypeNameNode %A" $1;
            mkNode(parseState, 1,{
                name = $1;
            })
        }

subtypeExpr:
    | LCURLY CHOICE singleTypingExpr DOT valueExpr CHOICE RCURLY
        {
            mkNode(parseState, 1,{
                singleTyping = $3;
                valueExpr = $5;
            })
        
        }

singleTypingExpr:
    | ident COLON typeExpr 
        { 
            mkNode(parseState, 1,{
                name = $1;
                typeExpr = $3;
            })
        }

bracketedTypeExpr:
    | LPAREN typeExpr RPAREN 
        {
            mkNode(parseState, 1,{
                typeExpr = $2;
            })
        }

typeExprProduct:
    | typeExpr PRODUCT typeExprProduct { $1 :: $3 }
    | typeExpr { [$1] }

valueExpr:
    | quantifiedExpr { $1 }

quantifiedExpr:
    | quantifiedOp singleTypingExprList DOT quantifiedExpr 
        {
            mkNode(parseState, 1,ValueExpr.QuantifiedExpr(mkNode(parseState, 1,{
                quantifier = $1;
                singleTypingList = $2;
                valueExpr = $4;
            })))
        }
    | axiomInfixExpr { $1 }

quantifiedOp:
    | EXISTS { Quantifiers.Exists }
    | FORALL { Quantifiers.Forall }

axiomInfixExpr:
    | impliesExpr { $1 }

impliesExpr:
    | orExpr IMPLIES impliesExpr 
        {
            mkNode(parseState, 1,ValueExpr.AxiomInfixExpr(mkNode(parseState, 2,{
                leftExpr = $1;
                infixConnective = InfixConnective.Implies;
                rightExpr = $3;
            })))
        }
    | orExpr { $1 }

orExpr:
    | orExpr OR andExpr 
        {
            mkNode(parseState, 1,ValueExpr.AxiomInfixExpr(mkNode(parseState, 2,{
                leftExpr = $1;
                infixConnective = InfixConnective.Or;
                rightExpr = $3;
            })))
        }
    | andExpr { $1 }

andExpr:
    | valueInfixExpr AND andExpr 
        {
           mkNode(parseState, 1, ValueExpr.AxiomInfixExpr(mkNode(parseState, 2,{
                leftExpr = $1;
                infixConnective = InfixConnective.And;
                rightExpr = $3;
            })))
        }
    | valueInfixExpr { $1 }

valueInfixExpr:
    | equalsExpr { $1 }

equalsExpr:
    | addExpr EQUALS equalsExpr 
        {
            mkNode(parseState, 1,ValueExpr.ValueInfixExpr(mkNode(parseState, 2,{
                leftExpr = $1;
                infixOperator = InfixOperator.Equals;
                rightExpr = $3;
            })))
        }
    | addExpr NOT_EQUALS equalsExpr 
        {
            mkNode(parseState, 1,ValueExpr.ValueInfixExpr(mkNode(parseState, 2,{
                leftExpr = $1;
                infixOperator = InfixOperator.NotEquals;
                rightExpr = $3;
            })))
        }
    | addExpr GT equalsExpr 
        {
            mkNode(parseState, 1,ValueExpr.ValueInfixExpr(mkNode(parseState, 2,{
                leftExpr = $1;
                infixOperator = InfixOperator.GreaterThan;
                rightExpr = $3;
            })))
        }
    | addExpr LT equalsExpr 
        {
            mkNode(parseState, 1,ValueExpr.ValueInfixExpr(mkNode(parseState, 2,{
                leftExpr = $1;
                infixOperator = InfixOperator.LessThan;
                rightExpr = $3;
            })))
        }
    | addExpr GEQ equalsExpr 
        {
            mkNode(parseState, 1,ValueExpr.ValueInfixExpr(mkNode(parseState, 2,{
                leftExpr = $1;
                infixOperator = InfixOperator.GreaterOrEqual;
                rightExpr = $3;
            })))
        }
    | addExpr LEQ equalsExpr 
        {
            mkNode(parseState, 1,ValueExpr.ValueInfixExpr(mkNode(parseState, 2,{
                leftExpr = $1;
                infixOperator = InfixOperator.LessOrEqual;
                rightExpr = $3;
            })))
        }
    | addExpr { $1 }

addExpr:
    | addExpr PLUS mulExpr 
        { 
            mkNode(parseState, 1,ValueExpr.ValueInfixExpr(mkNode(parseState, 2,{
                leftExpr = $1;
                infixOperator = InfixOperator.Add;
                rightExpr = $3;
            })))
         }
    | addExpr MINUS mulExpr 
        { 
            mkNode(parseState, 1,ValueExpr.ValueInfixExpr(mkNode(parseState, 2,{
                leftExpr = $1;
                infixOperator = InfixOperator.Subtract;
                rightExpr = $3;
            })))
         }
    | mulExpr { $1 }

mulExpr:
    | mulExpr MULTIPLY valueLiteralExpr 
        { 
            mkNode(parseState, 1,ValueExpr.ValueInfixExpr(mkNode(parseState, 2,{
                leftExpr = $1;
                infixOperator = InfixOperator.Multiply;
                rightExpr = $3;
            })))
         }
    | mulExpr DIVIDE valueLiteralExpr 
        { 
            mkNode(parseState, 1,ValueExpr.ValueInfixExpr(mkNode(parseState, 2,{
                leftExpr = $1;
                infixOperator = InfixOperator.Divide;
                rightExpr = $3;
            })))
         }
    | valueLiteralExpr { $1 }

valueLiteralExpr:
    | LIT_BOOL { printfn "ValueExpr.ValueLiteral %A" $1; mkNode(parseState, 1, ValueExpr.ValueLiteral(mkNode(parseState, 1, ValueLiteral.Bool($1)))) }
    | LIT_INT { printfn "ValueExpr.ValueLiteral %A" $1; mkNode(parseState, 1, ValueExpr.ValueLiteral(mkNode(parseState, 1, ValueLiteral.Int($1)))) }
    | valueNameExpr { $1 }

valueNameExpr:
    | ident { printfn "ValueExpr.ValueName %A" $1; mkNode(parseState, 1, ValueExpr.ValueName($1)) }
    | applicationExpr { $1 }

applicationExpr:
    | ident LPAREN valueExprList RPAREN 
        {
            mkNode(parseState, 1,ValueExpr.ApplicationExpr(mkNode(parseState, 1,{
                name = $1;
                args = $3;
            })))
        }
    | bracketedExpr { $1 }

valueExprList:
    | valueExpr COMMA valueExprList { $1 :: $3 }
    | valueExpr { [$1] }

bracketedExpr:
    | LPAREN valueExpr RPAREN 
        {
            mkNode(parseState, 1,ValueExpr.BracketedExpr(mkNode(parseState, 1,{
                valueExpr = $2;
            })))
        }
    | axiomPrefixExpr { $1 }

singleTypingExprList:
    | singleTypingExpr COMMA singleTypingExprList { $1 :: $3 }
    | singleTypingExpr { [$1] }

axiomPrefixExpr:
    | prefixConnective valueExpr 
        {
            mkNode(parseState, 1,ValueExpr.AxiomPrefixExpr(mkNode(parseState, 1,{
                prefixConnective = $1;
                valueExpr = $2;
            })))
        }
    | valuePrefixExpr { $1 }

prefixConnective:
    | NOT { PrefixConnective.Not }

valuePrefixExpr:
    | prefixOperator valueExpr 
        {
            mkNode(parseState, 1,ValueExpr.ValuePrefixExpr(mkNode(parseState, 1,{
                prefixOperator = $1;
                valueExpr = $2;
            })))
        }
    | letExpr { $1 }

prefixOperator:
    | ABS { PrefixOperator.Abs }

letExpr:
    | LET ident EQUALS valueExpr IN valueExpr END 
        {
             mkNode(parseState, 1,ValueExpr.LetExpr(mkNode(parseState, 1,{
                name = $2;
                initExpr = $4;
                scopeExpr = $6;
            })))
        
        }
    | ifExpr { $1 }

ifExpr:
    | IF valueExpr THEN valueExpr ELSE valueExpr END
        {
            mkNode(parseState, 1, ValueExpr.IfExpr(mkNode(parseState, 1,{
                condExpr = $2;
                thenExpr = $4;
                elseExpr = $6;
            })))
        }

ident:
    | IDENT { printfn "IDENTNODE %A" $1; $1 }